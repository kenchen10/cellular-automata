<style>
  body {
    margin: 0px;
    overflow: hidden;
  }
</style>
<body>
<script src="libraries/three.min.js"></script>
<script src="libraries/dat.gui.min.js"></script>
<script src="libraries/guify.js"></script>

<script id="vertexShader" type="x-shader/x-vertex">
    void main() {
        gl_Position = vec4( position, 1.0 );
    }
</script>
<script id="rule_ca" type="x-shader/x-fragment">
  uniform int u_rule[16];
  uniform vec2 u_resolution;
  uniform vec3 u_mouse;
  uniform sampler2D u_currentTexture;
  uniform int u_frameCount;
  uniform float u_mouseSize;
  uniform vec3 u_newLifeColor;
  uniform vec3 u_survivorColor;
  uniform int u_paused;
  uniform float u_colors[18];

  float v(float xrel, float yrel) {
    // Takes input relative to current pixel and returns pixel value.
    vec2 xy;
    xy.x = mod(gl_FragCoord.x + xrel, u_resolution.x);
    xy.y = mod(gl_FragCoord.y + yrel, u_resolution.y);

    return texture2D(u_currentTexture, xy/u_resolution).a;
  }

	void main() {
		float minRes = min(u_resolution.x, u_resolution.y);
		vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / minRes;
		float inputSize = u_mouseSize / minRes;

		float fate = float(v(0.,0.) == 1.);

		if(u_frameCount < 2) {
      //create random initial texture first 2 frames of program
      if (int(gl_FragCoord.x) == int(float(u_resolution.x) / 2.0) && int(gl_FragCoord.y) == int(float(u_resolution.y) / 2.0)) {
        fate = 1.0;
      }
		}

		else if (u_paused == 1) {
      int idx = int(v(-1., 1.)) * 1 + int(v(1., 1.)) * 2 + int(v(-1., -1.)) * 4 + int(v(1., -1.)) * 8;
      for (int i = 0; i < 16; ++i) {
        if (i == idx) {
          fate = float(u_rule[i]);
        }
      }
		}
		gl_FragColor = vec4(fate);
	}
</script>

<script id="life_ca" type="x-shader/x-fragment">
  uniform vec2 u_resolution;
  // uniform vec3 u_mouse;
  uniform sampler2D u_currentTexture;
  uniform int u_frameCount;
  uniform int u_surviveLength;
  uniform int u_bornLength;
  // uniform float u_mouseSize;
  // uniform vec3 u_newLifeColor;
  // uniform vec3 u_survivorColor;
  uniform int u_born[8];
  uniform int u_survive[8];
  uniform int u_paused;
	//random noise function for initial texture

  highp float rand(vec2 co)
	{
		highp float a = 12.9898;
		highp float b = 78.233;
		highp float c = 43758.5453;
		highp float dt= dot(co.xy ,vec2(a,b));
		highp float sn= mod(dt,3.14);
		return fract(sin(sn) * c);
	}

	float v(float xrel, float yrel) {
		vec2 xy;
		xy.x = mod(gl_FragCoord.x + xrel, u_resolution.x);
		xy.y = mod(gl_FragCoord.y + yrel, u_resolution.y);

		return texture2D(u_currentTexture, xy/u_resolution).a;
	}

	float neighborSum() {
		return 	v(-1.,-1.) +
				v(-1.,0.) +
				v(-1.,1.) +
				v(0.,-1.) +
				v(0.,1.) +
				v(1.,-1. )+
				v(1.,0.) +
				v(1.,1.);
	}

  // int includes(float v, int arr[8], int limit) {
  //   for (int i = 0; i < 8; ++i) {
  //     if (i > limit - 1) {
  //       return 1;
  //     }
  //   }
  //   return 1;
  // }

  void main()
	{
		float minRes = min(u_resolution.x, u_resolution.y);
		vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / minRes;
		// float inputSize = u_mouseSize / minRes;
		float fate = float(v(0.,0.) == 1.);
		float before = fate;
		if(u_frameCount < 2) //create random initial texture first 2 frames of program
		{
			float _rand = rand(uv*u_time);
			fate = clamp(floor(_rand * _rand * _rand * 1.2), 0., 1.);
		}

		else if (u_paused == 1)//calculate neighbor totals
		{
			float sum = neighborSum();
			bool a = (sum == 3. || (fate==1. && (sum == 2.)));
			fate = float(a);
		}

		// bool userInput = (u_mouse.z > 0.) &&
		// 				((uv.x >= u_mouse.x - inputSize && uv.x < u_mouse.x + inputSize) &&
		// 				(uv.y >= u_mouse.y - inputSize && uv.y < u_mouse.y + inputSize));
    //
		// fate  += float(userInput);
		gl_FragColor = vec4(fate);
		//change color based on status change
		// if(fate != before) {
		// 	gl_FragColor = vec4(vec3(u_survivorColor)/255.,fate);
		// } else if (before == fate && v(0.,0.) == 1.) {
		// 	gl_FragColor = vec4(vec3(u_newLifeColor)/255.,fate);
		// }
	}
</script>

<script id="cyclic_ca" type="x-shader/x-fragment">
  uniform vec2 u_resolution;
  // uniform vec3 u_mouse;
  uniform sampler2D u_currentTexture;
  uniform int u_frameCount;
  // uniform float u_mouseSize;
  uniform int u_paused;
  uniform float u_time;
  uniform int u_t;
  uniform int u_r;
  uniform int u_c;
  uniform bool u_moore;

  int r = 1;

	//random noise function for initial texture

  highp float rand(vec2 co)
	{
		highp float a = 12.9898;
		highp float b = 78.233;
		highp float c = 43758.5453;
		highp float dt= dot(co.xy ,vec2(a,b));
		highp float sn= mod(dt,3.14);
		return fract(sin(sn) * c);
	}

  float rand2(float n)
  {
    return fract(sin(n) * 43758.5453123);
  }

	float v(float xrel, float yrel) {
		vec2 xy;
		xy.x = mod(gl_FragCoord.x + xrel, u_resolution.x);
		xy.y = mod(gl_FragCoord.y + yrel, u_resolution.y);

		return texture2D(u_currentTexture, xy/u_resolution).a;
	}

  float getNextColor(float c) {
    for (int i = 0; i < 19; ++i) {
      if (u_c == i) {
        break;
      }
      float d = float(u_c - 1);
      if (abs(c - float(i) * 1. / d) < .01) {
        float nextColor = float(i) * 1. / d + 1. / d;
        if (abs(nextColor - 1. - 1./d) < 0.01) {
          nextColor = 0.0;
        }
        return nextColor;
      }
    }
  }

	int neighborSum() {
    int count = 0;
    if (u_moore) {
      // for (int x = 0; x > -6; --x) {
      //   for (int y = 0; y > -6; --y) {
      //     if (abs(abs(float(x)) - float(u_r)) < .01 && abs(abs(float(y)) - float(u_r)) < .01) {
      //       break;
      //     }
      //     if (abs(float(x)) > float(u_r) || abs(float(y)) > float(u_r)) {
      //       continue;
      //     }
      //     if (abs(v(float(x), float(y)) - getNextColor(v(0., 0.))) < .01) {
      //       count = count + 1;
      //     }
      //   }
      // }
      for (int x = -5; x < 6; ++x) {
        for (int y = -5; y < 6; ++y) {
          if (abs(float(x)) > float(u_r) || abs(float(y)) > float(u_r)) {
            continue;
          }
          if (abs(v(float(x), float(y)) - getNextColor(v(0., 0.))) < .01) {
            count = count + 1;
          }
        }
      }
    } else {
      if (abs(v(-1., 0.) - getNextColor(v(0., 0.))) < .01) {
        count = count + 1;
      }
      if (abs(v(1., 0.) - getNextColor(v(0., 0.))) < .01) {
        count = count + 1;
      }
      if (abs(v(0., 1.) - getNextColor(v(0., 0.))) < .01) {
        count = count + 1;
      }
      if (abs(v(0., -1.) - getNextColor(v(0., 0.))) < .01) {
        count = count + 1;
      }
    }
    return count;
	}

  void main()
	{
		float minRes = min(u_resolution.x, u_resolution.y);
		vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / minRes;
		// float inputSize = u_mouseSize / minRes;
		float fate = v(0.,0.);
		// float before = fate;
		if(u_frameCount < 2) //create random initial texture first 2 frames of program
		{
      float d = float(u_c - 1);
			float _rand = rand(uv * 1.9);
      float j = sign(_rand * d)*floor(abs(_rand * d)+.5);
      fate = (j) * 1. / d;
		}

		else if (u_paused == 1)//calculate neighbor totals
		{
			float sum = float(neighborSum());
			if (sum > float(u_t) || abs(sum - float(u_t)) < .01) {
        fate = getNextColor(v(0.,0.));
      } else {
        fate = v(0.,0.);
      }
		}
    gl_FragColor = vec4(fate);
	}
</script>

<script src="app.js"></script>

</body>
